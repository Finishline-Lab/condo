use namespace = 'System'
use namespace = 'System.Collections.Generic'
use namespace = 'System.Diagnostics'
use namespace = 'System.IO'
use namespace = 'System.Linq'

use namespace = 'Sake.Engine.Logging'

default Quiet = '${ false }'

@{
    // set the log instance on the helper class
    Build.Log = new QuietLog(this.Log, Quiet);

    // replace the current instance of the logger with the one that handles "quiet"
    this.Log = Build.Log;
}

functions @{
    public interface IQuietLog : ILog
    {
        bool Quiet { get; set; }

        bool Secure { get; set; }

        void Info(object value, bool secure);
        void Warn(object value, bool secure);
        void Error(object value, bool secure);
        void Verbose(object value, bool secure);
        void Argument(string name, object value, bool secure);
    }

    public class QuietLog : IQuietLog
    {
        private ILog log;

        private const string ArgumentFormat = "- {0,-20}: {1}";

        public QuietLog(ILog log, bool quiet)
        {
            this.Quiet = quiet;
            this.log = log;
        }

        public void Info(object value)
        {
            var padded = (value ?? string.Empty).ToString().Trim();
            padded = padded.PadLeft(3 + padded.Length);

            this.log.Info(padded);
        }

        public void Info(object value, bool secure)
        {
            this.Info(this.Secure && secure ? "<secured>" : value);
        }

        public void Warn(object value)
        {
            var padded = (value ?? string.Empty).ToString().Trim();
            padded = padded.PadLeft(3 + padded.Length);

            this.log.Warn(padded);
        }

        public void Warn(object value, bool secure)
        {
            this.Warn(this.Secure && secure ? "<secured>" : value);
        }

        public void Error(object value)
        {
            var padded = (value ?? string.Empty).ToString().Trim();
            padded = padded.PadLeft(2 + padded.Length);

            this.log.Error(padded);
        }

        public void Error(object value, bool secure)
        {
            this.Error(this.Secure && secure ? "<secured>" : value);
        }

        public void Verbose(object value)
        {
            if (!this.Quiet)
            {
                this.log.Verbose(value);
            }
        }

        public void Verbose(object value, bool secure)
        {
            this.Verbose(this.Secure && secure ? "<secured>" : value);
        }

        public void Argument(string name, object value, bool secure)
        {
            if (this.Secure && secure)
            {
                value = "<secured>";
            }

            this.Verbose(string.Format(ArgumentFormat, name, value), false);
        }

        public bool Quiet { get; set; }
        public bool Secure {get; set; }
    }

    public class InstallPath
    {
        public string Path { get; set; }
        public bool Global { get; set; }
    }

    /// <summary>
    /// Represents a helper class used to store and retrieve build environment configuration.
    /// </summary>
    public static class Build
    {
        private static readonly string[] DefaultExcludes = new[] { "node_modules", "bower_components", "wwwroot" };

        private static readonly IList<Process> Processes = new List<Process>();

        private static readonly IDictionary<string, InstallPath> InstallPaths = new Dictionary<string, InstallPath>();

        /// <summary>
        /// Gets a value indicating whether or not the build environment is running on a Unix-based
        /// host.
        /// </summary>
        public static bool Unix
        {
            get
            {
                // get the platform identifier as an integer
                // tricky: this is necessary as the 1.x mono runtime used a value of 128 for
                // unix environments, which doesn't exist on the PlatformID enumeration in
                // .NET or in 2.x mono runtime
                var id = (int)Environment.OSVersion.Platform;

                // tricky:
                //  - 4 = Mac OS X (DNX / Mono 2.x)
                //  - 6 = Unix (DNX / Mono 2.x)
                //  - 128 = Unix (Mono 1.x)
                return id == 4 || id == 6 || id == 128;
            }
        }

        /// <summary>
        /// Gets a value indicating whether or not the build environment is running on an OS X-based
        /// host.
        /// </summary>
        public static bool OSX
        {
            get
            {
                // get the platform id
                var id = (int)Environment.OSVersion.Platform;

                // determine if the platform is OS X
                return id == 4;
            }
        }

        /// <summary>
        /// Gets a value indicating whether or not the build environment is executing within the
        /// mono runtime.
        /// </summary>
        public static bool Mono
        {
            get
            {
                return Type.GetType("Mono.Runtime") != null;
            }
        }

        /// <summary>
        /// Gets the path for the specified name.
        /// </summary>
        public static InstallPath GetPath(string name)
        {
            InstallPath path;

            if (InstallPaths.TryGetValue(name, out path))
            {
                return path;
            }

            return null;
        }

        public static InstallPath GetOrSetPath(string name, string path, bool global)
        {
            InstallPath temp;

            if (InstallPaths.TryGetValue(name, out temp))
            {
                return temp;
            }

            temp = new InstallPath { Path = path, Global = global };

            InstallPaths.Add(name, temp);

            return temp;
        }

        public static InstallPath SetPath(string name, string path, bool global)
        {
            var temp = new InstallPath { Path = path, Global = global };

            InstallPaths[name] = temp;

            return temp;
        }

        /// <summary>
        /// Gets the value of the environment variable with the specified <paramref name="key"/>.
        /// </summary>
        /// <param name="key">
        /// The name of the environment variable for which to retrieve a value.
        /// </param>
        /// <param name="default">
        /// The default value if no value is present.
        /// </param>
        /// <returns>
        /// The value of the environment variable with the specified <paramref name="key"/>; otherwise
        /// <see langword="string.Empty"/>.
        /// </returns>
        public static string Get(string key, string @default = "")
        {
            // get the environment variable
            return Environment.GetEnvironmentVariable(key) ?? @default;
        }

        /// <summary>
        /// Sets the environment variable with the specified <paramref name="key"/> to the specified
        /// <paramref name="value"/>.
        /// </summary>
        /// <param name="key">
        /// The name of the environment variable to set to the specified <paramref name="value"/>.
        /// </param>
        /// <param name="value">
        /// The value to which to set the environment variable with the specified <paramref name="key"/>.
        /// </param>
        /// <param name="replace">
        /// A value indicating whether or not to append the value to any existing value.
        /// </param>
        public static void Set(string key, string value, bool append = false)
        {
            // determine if the value is being appended
            if (append)
            {
                // get the current value and append the new value; finally trim any whitespace
                value = string.Concat(Build.Get(key), " ", value).Trim();
            }

            // set the environment variable
            Environment.SetEnvironmentVariable(key, value);
        }

        /// <summary>
        /// Attempts to execute the specified <paramref name="command"/> with the optionally specified <paramref name="args"/>.
        /// </summary>
        /// <param name="command">
        /// The command that should be executed at the CLI.
        /// </param>
        /// <param name="exitCode">
        /// When the method returns, the exit code of the process that was used to execute the specified <paramref name="command"/>.
        /// </param>
        /// <param name="args">
        /// Additional arguments to pass to the specified <paramref name="command"/>.
        /// </param>
        /// <param name="workingPath">
        /// The working path in which the specified <paramref name="command"/> should be executed.
        /// </param>
        /// <param name="quiet">
        /// A value indicating whether or not to execute the specified <paramref name="command"/> without emitting output from the
        /// process.
        /// </param>
        public static bool TryExecute(string command, out int exitCode, string args = "", string workingPath = "", bool quiet = false)
        {
            string result;

            try
            {
                // attempt to execute the command
                exitCode = Build.Execute(command, out result, args, workingPath, quiet);
            }
            catch
            {
                // set the exit code to -1 as a default error
                exitCode = -1;
            }

            // return true if the exit code is 0
            return exitCode == 0;
        }

        /// <summary>
        /// Attempts to execute the specified <paramref name="command"/> with the optionally specified <paramref name="args"/>.
        /// </summary>
        /// <param name="command">
        /// The command that should be executed at the CLI.
        /// </param>
        /// <param name="exitCode">
        /// When the method returns, the exit code of the process that was used to execute the specified <paramref name="command"/>.
        /// </param>
        /// <param name="result">
        /// When the method returns, will contain the output from standard output if the process was successful or standard error if the process
        /// was not successful.
        /// </param>
        /// <param name="args">
        /// Additional arguments to pass to the specified <paramref name="command"/>.
        /// </param>
        /// <param name="workingPath">
        /// The working path in which the specified <paramref name="command"/> should be executed.
        /// </param>
        /// <param name="quiet">
        /// A value indicating whether or not to execute the specified <paramref name="command"/> without emitting output from the
        /// process.
        /// </param>
        /// <param name="wait">
        /// A value indicating whether or not to wait for the process to exit.
        /// </param>
        /// <param name="attempts">
        /// The total number of attempts to try for a successful result.
        /// </param>
        public static bool TryExecute(string command, out int exitCode, out string result, string args = "", string workingPath = "", bool quiet = true, bool wait = true, int attempts = 1)
        {
            result = null;

            try
            {
                // attempt to execute the command
                exitCode = Build.Execute(command, out result, args, workingPath, quiet, wait, attempts);
            }
            catch (Exception netEx)
            {
                // set the exit code to -1 as a default error
                exitCode = -1;

                // set the result to the message
                result = netEx.Message;
            }

            // return true if the exit code is 0
            return exitCode == 0;
        }

        /// <summary>
        /// Executes the specified <paramref name="command"/> with the specified <paramref name="arguments"/> and determines
        /// whether or not it succeeds at the command line.
        /// </summary>
        /// <param name="command">
        /// The command to execute at the command line.
        /// </param>
        /// <param name="args">
        /// The arguments to execute at the command line.
        /// </param>
        /// <param name="workingPath">
        /// The path in which to execute the specified <paramref name="command"/>.
        /// </param>
        /// <param name="quiet">
        /// A value indicating whether or not to execute the specified <paramref name="command"/> without emitting output from the
        /// process.
        /// </param>
        public static bool TryExecute(string command, string args = "", string workingPath = "", bool quiet = false)
        {
            string result;
            int exitCode;

            return Build.TryExecute(command, out exitCode, out result, args, workingPath, quiet);
        }

        /// <summary>
        /// Executes the specified <paramref name="command"/> with the specified <paramref name="arguments"/> and determines
        /// whether or not it succeeds at the command line.
        /// </summary>
        /// <param name="command">
        /// The command to execute at the command line.
        /// </param>
        /// <param name="result">
        /// When the method returns, will contain the output from standard output if the process was successful or standard error if the process
        /// was not successful.
        /// </param>
        /// <param name="args">
        /// The arguments to execute at the command line.
        /// </param>
        /// <param name="workingPath">
        /// The path in which to execute the specified <paramref name="command"/>.
        /// </param>
        /// <param name="quiet">
        /// A value indicating whether or not to execute the specified <paramref name="command"/> without emitting output from the
        /// process.
        public static bool TryExecute(string command, out string result, string args = "", string workingPath = "")
        {
            result = null;

            int exitCode;

            return Build.TryExecute(command, out exitCode, out result, args, workingPath, true);
        }

        /// <summary>
        /// Executes the specified <paramref name="command"/> with the specified <paramref name="arguments"/> and determines
        /// whether or not it succeeds at the command line.
        /// </summary>
        /// <param name="command">
        /// The command to execute at the command line.
        /// </param>
        /// <param name="args">
        /// The arguments to execute at the command line.
        /// </param>
        /// <param name="workingPath">
        /// The path in which to execute the specified <paramref name="command"/>.
        /// </param>
        /// <param name="quiet">
        /// A value indicating whether or not to execute the specified <paramref name="command"/> without emitting output from the
        /// process.
        /// </param>
        public static int Execute(string command, string args = "", string workingPath = "", bool quiet = false)
        {
            string result;

            return Build.Execute(command, out result, args, workingPath, quiet);
        }

        /// <summary>
        /// Executes the specified <paramref name="command"/> with the specified <paramref name="arguments"/> and determines
        /// whether or not it succeeds at the command line.
        /// </summary>
        /// <param name="command">
        /// The command to execute at the command line.
        /// </param>
        /// <param name="result">
        /// When the method returns, will contain the output from standard output if the process was successful or standard error if the process
        /// was not successful.
        /// </param>
        /// <param name="args">
        /// The arguments to execute at the command line.
        /// </param>
        /// <param name="workingPath">
        /// The path in which to execute the specified <paramref name="command"/>.
        /// </param>
        /// <param name="quiet">
        /// A value indicating whether or not to execute the specified <paramref name="command"/> without emitting output from the
        /// process.
        /// </param>
        /// <param name="wait">
        /// A value indicating whether or not to wait for the process to exit.
        /// </param>
        /// <param name="attempts">
        /// The total number of attempts to try for a successful result.
        /// </param>
        public static int Execute(string command, out string result, string args = "", string workingPath = "", bool quiet = true, bool wait = true, int attempts = 1)
        {
            result = null;

            // determine if the working path is specified
            if (string.IsNullOrEmpty(workingPath))
            {
                // set the working path to the current directory
                workingPath = Directory.GetCurrentDirectory();
            }

            if (command.Contains(" "))
            {
                command = "\"" + command + "\"";
            }

            // determine process start information based on whether or not the CLI is executing on unix/linux or windows
            var info = Build.Unix
                ? new ProcessStartInfo { FileName = command, Arguments = args }
                : new ProcessStartInfo { FileName = "cmd", Arguments = " /S /C \"" + command + " " + args + "\"" };

            info.WorkingDirectory = workingPath;
            info.UseShellExecute = false;

            if (quiet)
            {
                info.RedirectStandardOutput = true;
                info.RedirectStandardError = true;
            }

            var retries = attempts;
            var exitCode = -1;

            while (retries-- > 0)
            {
                // start the process
                var process = Process.Start(info);

                if (wait || process.HasExited)
                {
                    // wait for the process to exit
                    process.WaitForExit();

                    if (quiet)
                    {
                        // read out the results
                        result = (process.ExitCode == 0 ? process.StandardOutput.ReadToEnd() : process.StandardError.ReadToEnd()).Trim();
                    }

                    // determine if the exit code is zero
                    if (process.ExitCode == 133 || process.ExitCode == 0)
                    {
                        // move on immediately
                        return 0;
                    }

                    // set the exit code
                    exitCode = process.ExitCode;

                    // try again
                    continue;
                }

                // track the process
                Processes.Add(process);

                // return zero, since we can't do anything else
                return 0;
            }

            // return the exit code from the process
            return exitCode;
        }

        public static void Wait()
        {
            Console.WriteLine(string.Empty);

            do
            {
                Console.WriteLine("Press <enter> or <return> to stop all processes and exit.");
            } while(!Console.ReadKey().Key.Equals(ConsoleKey.Enter));

            foreach (var process in Processes)
            {
                try
                {
                    process.Kill();
                }
                catch
                {
                }
            }
        }

        public static IEnumerable<string> GetPathsContaining(string path, string filter, params string[] excludes)
        {
            if (string.IsNullOrEmpty(path))
            {
                path = Directory.GetCurrentDirectory();
            }

            if (!Directory.Exists(path))
            {
                return new List<string>();
            }

            excludes = DefaultExcludes.Union(excludes).ToArray();

            var files = Directory.GetFiles(path, filter, SearchOption.AllDirectories).AsEnumerable();

            var separator = Path.DirectorySeparatorChar;

            foreach (var exclude in excludes)
            {
                files = files.Where(f => f.IndexOf(separator + exclude.Trim(separator) + separator) < 0);
            }

            return files.Select(f => Path.GetDirectoryName(f)).Distinct();
        }

        public static IEnumerable<string> GetPaths(string path, string filter)
        {
            if (string.IsNullOrEmpty(path))
            {
                path = Directory.GetCurrentDirectory();
            }

            if (!Directory.Exists(path))
            {
                return new List<string>();
            }

            return Directory
                .EnumerateFiles(path, filter, SearchOption.AllDirectories)
                .Distinct();
        }

        /// <summary>
        /// Creates the directory (recursively) at the specified <paramref name="path"/>.
        /// </summary>
        /// <param name="path">
        /// The fully-qualified path of the directory to create.
        /// </param>
        public static string MakeDirectory(string path)
        {
            return Directory.Exists(path) ? path : Directory.CreateDirectory(path).FullName;
        }

        public static void RemoveDirectory(string path)
        {
            if (!Directory.Exists(path))
            {
                return;
            }

            var dir = new DirectoryInfo(path);
            dir.Attributes &= ~FileAttributes.ReadOnly;

            foreach (var info in dir.GetFileSystemInfos("*", SearchOption.AllDirectories))
            {
                info.Attributes &= ~FileAttributes.ReadOnly;
            }

            dir.Delete(true);
        }

        public static bool TryGetRepositoryRoot(ref string root)
        {
            try
            {
                if (!Directory.Exists(root))
                {
                    return false;
                }

                var current = new DirectoryInfo(root);

                string path;

                do
                {
                    path = Path.Combine(current.FullName, ".git");

                    if (Directory.Exists(path))
                    {
                        root = current.FullName;

                        return true;
                    }
                }   while((current = current.Parent) != null);
            }
            catch (Exception netEx)
            {
                Log.Verbose(netEx.Message);

                return false;
            }

            return false;
        }

        /// <summary>
        /// Gets or sets the log used to emmit log entries.
        /// </summary>
        public static IQuietLog Log { get; set; }
    }
}