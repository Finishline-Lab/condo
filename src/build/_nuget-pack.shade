
@{/*

nuget-pack
    Executes a nuget package manager command to pack the specified packages.

nuget_pack_options='' (Environment Variable: NUGET_PACK_OPTIONS)
    Additional options to include when executing the nuget command line tool for the pack operation.

nuget_pack_path='$(working_path)'
    The path to the nuget specification or project that should be packed or the directory in which
    a nuget specification or project should be found.

nuget_pack_version='$(AssemblyInfo.InformationalVersion)'
    The version used to override the version defined in a nuget specification.

base_path='$(CurrentDirectory)'
    The base path in which to execute the nuget command line tool.

working_path='$(base_path)'
    The working path in which to execute the nuget command line tool.

*/}

use namespace = 'System'
use namespace = 'System.IO'
use namespace = 'System.Linq'
use namespace = 'System.Threading.Tasks'

use import = 'Condo.Build'

default base_path           = '${ Directory.GetCurrentDirectory() }'
default working_path        = '${ base_path }'
default target_path         = '${ Path.Combine(base_path, "artifacts") }'
default target_build_path   = '${ Path.Combine(target_path, "build") }'
default target_package_path = '${ Path.Combine(target_path, "packages") }'

default nuget_pack_path     = '${ working_path }'

info-collect once='info-collect'

default nuget_pack_version  = '${ AssemblyInfo.InformationalVersion }'
default nuget_pack_options  = '${ Build.Get("NUGET_PACK_OPTIONS") }'

default configuration       = '${ Build.Get("CONFIGURATION", "Debug") }'
default platform            = '${ Build.Get("PLATFORM", "Any CPU") }'
default product             = ''
default company             = ''

@{
    Build.Log.Header("nuget-pack");
    Build.Log.Argument("options", nuget_pack_options);
    Build.Log.Argument("path", nuget_pack_path);
    Build.Log.Argument("version", nuget_pack_version);
    Build.Log.Header();

    if (!string.IsNullOrEmpty(nuget_pack_version))
    {
        nuget_pack_options += " -Version " + nuget_pack_version;
    }

    if (!string.IsNullOrEmpty(target_package_path))
    {
        nuget_pack_options += " -OutputDirectory \"" + target_package_path + "\"";

        Directory.CreateDirectory(target_package_path);
    }

    if (Directory.Exists(nuget_pack_path))
    {
        var nuget_pack_projs = Directory.EnumerateFiles(nuget_pack_path, "*.??proj")
            .Where(p => File.Exists(Path.ChangeExtension(p, ".nuspec")));

        var nuget_pack_deploys = Directory.EnumerateFiles(nuget_pack_path, "*.??proj")
            .Select(p => Path.ChangeExtension(p, ".deploy.nuspec"))
            .Where(p => File.Exists(p));

        var nuget_pack_specs = Directory.EnumerateFiles(nuget_pack_path, "*.nuspec")
            .Where(p => !File.Exists(Path.ChangeExtension(p, ".csproj")))
            .Where(p => !File.Exists(Path.ChangeExtension(p, ".vbproj")))
            .Except(nuget_pack_deploys);

        try
        {
            Parallel.ForEach
                (
                    nuget_pack_projs,
                    path => Pack("pack \"" + path + "\"", nuget_pack_options, Path.Combine(target_build_path, Path.GetFileNameWithoutExtension(path)), Build.Log.Quiet, configuration, platform, product, company)
                );

            Parallel.ForEach
                (
                    nuget_pack_deploys,
                    path => Pack("pack \"" + path + "\"", nuget_pack_options, Path.Combine(target_build_path, Path.GetFileNameWithoutExtension(Path.GetFileNameWithoutExtension(path))), Build.Log.Quiet, configuration, platform, product, company)
                );

            Parallel.ForEach
                (
                    nuget_pack_specs,
                    path => Pack("pack \"" + path + "\"", nuget_pack_options, Path.GetDirectoryName(nuget_pack_path), Build.Log.Quiet, configuration, platform, product, company)
                );
        }
        catch (AggregateException agEx)
        {
            foreach(var ex in agEx.InnerExceptions)
            {
                Log.Warn("nuget-pack: " + ex.Message);
            }

            throw;
        }
    }
    else
    {
        if (!File.Exists(nuget_pack_path))
        {
            throw new ArgumentException("nuget-pack: the specified path for the specification or project was not found.", "nuget_pack_path");
        }

        Pack("pack \"" + nuget_pack_path + "\"", nuget_pack_options, Path.GetDirectoryName(nuget_pack_path), Build.Log.Quiet, configuration, platform, product, company);
    }
}

macro name='Pack' nuget_args='string' nuget_options='string' nuget_path='string' nuget_quiet='bool' configuration='string' platform='string' product='string' company='string'
    @{
        nuget_options += " -IncludeReferencedProjects -Properties \"Configuration=" + configuration + ";Platform=" + platform + ";OutDir=" + nuget_path;

        if(nuget_args.EndsWith("proj\""))
        {
            nuget_options += "\" -Symbols";
        }
        else if(nuget_args.EndsWith("deploy.nuspec\""))
        {
            var nuget_pack_temp_path = nuget_path.Trim(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
            var nuget_pack_temp_parts = nuget_pack_temp_path.Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
            var nuget_pack_id = nuget_pack_temp_parts[nuget_pack_temp_parts.Length-1];

            nuget_options += ";id=" + nuget_pack_id + ";author=" + company + "\" -NoPackageAnalysis";
        }
        else
        {
            nuget_options += ";id=" + product + ";author=" + company + "\"";
        }
    }
    nuget