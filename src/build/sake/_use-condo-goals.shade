use namespace = 'System'
use namespace = 'System.IO'

use import = 'Condo.Build'
use import = 'Condo.AssemblyInfo'

default base_path           = '${ Build.Get("BUILD_SOURCESDIRECTORY", Directory.GetCurrentDirectory()) }'

default target_path         = '${ Build.Get("BUILD_BINARIESDIRECTORY", Path.Combine(base_path, "artifacts")) }'
default bin_path            = '${ Path.Combine(base_path, "bin") }'
default src_path            = '${ Path.Combine(base_path, "src") }'
default test_path           = '${ Path.Combine(base_path, "test") }'
default working_path        = '${ base_path }'
default appdata_path        = '${ Build.Get("AGENT_BUILDDIRECTORY", Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData)) }'

default target_build_path   = '${ Path.Combine(target_path, "build") }'
default target_test_path    = '${ Build.Get("COMMON_TESTRESULTSDIRECTORY", Path.Combine(target_path, "test")) }'
default target_package_path = '${ Path.Combine(target_path, "packages") }'

default version             = '${ Build.Get("BUILD_VERSION", "1.0.0") }'
default configuration       = '${ Build.Get("CONFIGURATION", "Debug") }'

default Coverage            = '${ false }'

@{
    // set the log instance on the helper class
    Build.Log = new QuietLog(this.Log, false);

    // replace the current instance of the logger with the one that handles "quiet"
    this.Log = Build.Log;

    if (!string.IsNullOrEmpty(version))
    {
        // set the assembly version
        AssemblyInfo.AssemblyVersion = version;
    }

    // determine if the src path was overwritten without using a fully-qualified path
    if (!src_path.Contains(Path.DirectorySeparatorChar) && !src_path.Contains(Path.AltDirectorySeparatorChar))
    {
        // make src path a fully qualified path
        src_path = Path.Combine(base_path, src_path);
    }

    // determine if the test path was overwritten without using a fully-qualified path
    if (!test_path.Contains(Path.DirectorySeparatorChar) && !test_path.Contains(Path.AltDirectorySeparatorChar))
    {
        // make the test path a fully qualified path
        test_path = Path.Combine(base_path, test_path);
    }
}

#--quiet @{
    Build.Log.Quiet = true;
}

#--coverage @{
    Coverage = true;
}

#-q .--quiet

#print-properties
    log log_line='-'
    log log_header='paths'
    log log_line='-'
    log log_name='base path'            log_value='${ base_path }'
    log log_name='source path'          log_value='${ src_path }'
    log log_name='test path'            log_value='${ test_path }'
    log log_name='working path'         log_value='${ working_path }'
    log log_name='bin path'             log_value='${ bin_path }'
    log log_name='target path'          log_value='${ target_path }'
    log log_name='build results path'   log_value='${ target_build_path }'
    log log_name='test results path'    log_value='${ target_test_path }'
    log log_name='nuget packages path'  log_value='${ target_package_path }'
    log log_line='-'

    log log_header='options'
    log log_line='-'
    log log_name='configuration' log_value='${ string.IsNullOrEmpty(configuration) ? "<All>" : configuration }'
    log log_name='version' log_value='${ AssemblyInfo.AssemblyVersion }'
    log log_name='date time (utc)' log_value='${ AssemblyInfo.BuildDateUtc }'
    log log_name='quiet' log_value='${ Build.Log.Quiet }'
    log log_line='-'

#clean-bin description='Cleans the bin directory.' -Build.RemoveDirectory(bin_path);

#clean-npm-modules description='Cleans any installed NPM modules.' @{
    var paths = Build.GetPathsContaining(base_path, "package.json").Select(p => Path.Combine(p, "node_modules")).Where(p => Directory.Exists(p));

    foreach (var path in paths)
    {
        Build.RemoveDirectory(path);
    }

    Build.RemoveDirectory(Path.Combine(base_path, "node_modules"));
}

#clean-bower-components description='Cleans any installed bower components.' @{
    var paths = Build.GetPathsContaining(base_path, "package.json").Select(p => Path.Combine(p, "bower_components")).Where(p => Directory.Exists(p));

    foreach (var path in paths)
    {
        Build.RemoveDirectory(path);
    }
}

#clean-artifacts target='clean' description='Cleans the artifacts directory from the working directory.' -Build.RemoveDirectory(target_path);

#clean-build target='clean' description='Clean the build artifacts from each project within the working directory.'
    var paths = '${ Build.GetPathsContaining(base_path, "project.json") }'
    clean each='var clean_path in paths'

#clean-all .clean-bower-components .clean-npm-modules .clean-bin .clean description='Clean everything in preparation for `git clean`.'

#restore-npm-modules description='Restores all NPM modules. This will install NodeJS and NPM if not already found on the system.'
    var paths = '${ Build.GetPathsContaining(base_path, "package.json") }'
    npm-install each='var npm_install_path in paths'

#restore-bower-components description='Restores all Bower components. This will install the Bower node module if not already found on the system.'
    var paths = '${ Build.GetPathsContaining(base_path, "bower.json") }'
    bower-install each='var bower_install_path in paths'

#restore-project-packages description='Restores all NuGet packages (project.json).'
    var paths = '${ Build.GetPathsContaining(base_path, "project.json") }'
    dnu-restore each='var dnu_restore_path in paths'

#restore-nuget-packages description='Restores all NuGet packages (packages.config).'
    var paths = '${ Build.GetPathsContaining(src_path, "packages.config").Union(Build.GetPathsContaining(test_path, "packages.config")) }'
    nuget-restore each='var nuget_restore_path in paths'

#restore-packages .restore-project-packages .restore-nuget-packages .restore-npm-modules .restore-bower-components target='restore' description='Restores all NuGet packages, Bower components, and NPM modules.'

#initialize-grunt description='Initializes the project by executing the default grunt task. This will install the grunt node module if not already found on the system.'
    var paths = '${ Build.GetPathsContaining(base_path, "gruntfile.js") }'
    grunt each='var grunt_path in paths'

#initialize-gulp description='Initializes the project by executing the default gulp task. This will install the gulp node module if not already found on the system.'
    var paths = '${ Build.GetPathsContaining(base_path, "gulpfile.js") }'
    gulp each='var gulp_path in paths'

#initialize-info
    var paths = '${ Build.GetPathsContaining(base_path, "project.json") }'
    info each='var info_path in paths'

#initialize-all .initialize-info .initialize-grunt .initialize-gulp target='initialize' description='Initializes all initialization targets.'

#compile-dnx target='compile' description='Compiles and packages all dnx-based projects found within the source directory.'
    var paths = '${ Build.GetPathsContaining(src_path, "project.json") }'
    dnu-pack dnu_pack_output_path='${ target_build_path }' each='var dnu_pack_path in paths'

#test-dnx target='test' description='Executes unit tests for all dnx-based projects found within the test directory.'
    var paths = '${ Build.GetPathsContaining(test_path, "project.json") }'
    dnx-test dnx_test_output_path='${ target_test_path }' each='var dnx_test_path in paths'

#test-mocha target='test' description='Executes client-side tests using mocha'
    var paths = '${ Build.GetPathsContaining(src_path, "project.json").Where(path => { var test = Path.Combine(path, "test"); return Directory.Exists(test) && Directory.GetFiles(test, "*.js").Any(); }) }'
    mocha mocha_output_path='${ target_test_path }' each='var mocha_path in paths'

#test-compile-dnx target='compile' description='Compiles dnx-based projects found within the test directory.'
    var paths = '${ Build.GetPathsContaining(test_path, "project.json") }'
    dnu-build dnu_build_output_path='${ target_test_path }' each='var dnu_build_path in paths'

#test-coverage-dnx target='test-coverage' description='Generates a code coverage report for DNX-based projects'
    cover-report if='Coverage'

#pack-nuget-packages target='package' description='Packages NuGet specifications found within the source directory.'
    var specs = '${ Build.GetPaths(src_path, "*.nuspec") }'
    nuget-pack nuget_pack_output_path='${ target_package_path }' each='var nuget_pack_path in specs'

#push-nuget-packages-local target='post-package' description='Pushes NuGet packages to the local feed for development purposes.' if='Directory.Exists(target_package_path)'
    copy copy_src_path='${ target_package_path }' copy_dst_path='${ Path.Combine(appdata_path, "NuGet", "packages") }' copy_include="**/*.nupkg" copy_overwrite='${ true }'

#push-nuget-packages target='push' description='Pushes NuGet packages to the a NuGet feed.'
    var pkgs = '${ Build.GetPaths(target_package_path, "*.nupkg") }'
    nuget-push each='var nuget_push_args in pkgs'

#run-dnx target='run' description='Runs any DNX projects that contain a command for execution based on the platform.'
    var paths = '${ Build.GetPathsContaining(src_path, "project.json") }'
    dnx-run each='var dnx_run_project in paths'
    - Build.Wait();