use namespace = "System"
use namespace = "System.Collections.Generic"
use namespace = "System.IO"
use namespace = "System.Linq"
use namespace = "System.Net"
use namespace = "System.Net.Sockets"
use namespace = "System.Text"
use namespace = "System.Text.RegularExpressions"

use namespace = "Sake.Engine.Logging"

@{
    // set the log instance on the helper class
    Build.Log = this.Log;
}

functions @{
    /// <summary>
    /// Represents a helper class used to store and retrieve build environment configuration.
    /// </summary>
    public static class Build
    {
        private static readonly string[] DefaultExcludes = new[] { "node_modules", "bower_components" };

        /// <summary>
        /// Gets a value indicating whether or not the build environment is running on a Unix-based 
        /// host.
        /// </summary>
        public static bool Unix
        {
            get
            {
                // get the platform identifier as an integer
                // tricky: this is necessary as the 1.x mono runtime used a value of 128 for 
                // unix environments, which doesn't exist on the PlatformID enumeration in 
                // .NET or in 2.x mono runtime
                var id = (int)Environment.OSVersion.Platform;

                // tricky:
                //  - 4 = Mac OS X (DNX / Mono 2.x)
                //  - 6 = Unix (DNX / Mono 2.x)
                //  - 128 = Unix (Mono 1.x)
                return id == 4 || id == 6 || id == 128;
            }
        }

        /// <summary>
        /// Gets a value indicating whether or not the build environment is executing within the 
        /// mono runtime.
        /// </summary>
        public static bool Mono
        {
            get
            {
                return Type.GetType("Mono.Runtime") != null;
            }
        }

        /// <summary>
        /// Gets the value of the environment variable with the specified <paramref name="key"/>.
        /// </summary>
        /// <param name="key">
        /// The name of the environment variable for which to retrieve a value.
        /// </param>
        /// <returns>
        /// The value of the environment variable with the specified <paramref name="key"/>; otherwise 
        /// <see langword="null"/>.
        /// </returns>
        public static string Variable(string key)
        {
            // get the environment variable
            return Environment.GetEnvironmentVariable(key) ?? string.Empty;
        }

        /// <summary>
        /// Sets the environment variable with the specified <paramref name="key"/> to the specified 
        /// <paramref name="value"/>.
        /// </summary>
        /// <param name="key">
        /// The name of the environment variable to set to the specified <paramref name="value"/>.
        /// </param>
        /// <param name="value">
        /// The value to which to set the environment variable with the specified <paramref name="key"/>.
        /// </param>
        /// <param name="replace">
        /// A value indicating whether or not to append the value to any existing value.
        /// </param>
        public static void Variable(string key, string value, bool append = false)
        {
            // determine if the value is being appended
            if (append)
            {
                // get the current value and append the new value; finally trim any whitespace
                value = string.Concat(Build.Variable(key), " ", value).Trim();
            }

            // set the environment variable
            Environment.SetEnvironmentVariable(key, value);
        }

        public static bool TryExecute(string command, out int exitCode, string args = "", string workingPath = "")
        {
            try
            {
                // attempt to execute the command
                exitCode = Build.Execute(command, args, workingPath);
            }
            catch
            {
                // set the exit code to -1 as a default error
                exitCode = -1;
            }

            // return true if the exit code is 0
            return exitCode == 0;
        }

        public static bool TryExecute(string command, string args = "", string workingPath = "")
        {
            int exitCode;

            return Build.TryExecute(command, out exitCode, args, workingPath);
        }

        /// <summary>
        /// Executes the specified <paramref name="command"/> with the specified <paramref name="arguments"/> and determines
        /// whether or not it succeeds at the command line.
        /// </summary>
        /// <param name="command">
        /// The command to execute at the command line.
        /// </param>
        /// <param name="arguments">
        /// The arguments to execute at the command line.
        /// </param>
        /// <param name="workingPath">
        /// The path in which to execute the specified <paramref name="command"/>.
        /// </param>
        public static int Execute(string command, string args = "", string workingPath = "")
        {
            // determine if the working path is specified
            if (string.IsNullOrEmpty(workingPath))
            {
                // set the working path to the current directory
                workingPath = Directory.GetCurrentDirectory();
            }

            // determine process start information based on whether or not the CLI is executing on unix/linux or windows
            var info = Build.Unix
                ? new ProcessStartInfo { FileName = command, Arguments = args }
                : new ProcessStartInfo { FileName = "cmd", Arguments = "/C " + command + " " + args };

            info.WorkingDirectory = workingPath;
            info.UseShellExecute = false;
            info.RedirectStandardInput = true;
            info.RedirectStandardOutput = true;
            info.RedirectStandardError = true;

            // start the process
            var process = Process.Start(info);

            // wait for the process to exit
            process.WaitForExit();

            // get the exit code
            return process.ExitCode;
        }

        public static IEnumerable<string> GetPathsContaining(string path, string filter, params string[] excludes)
        {
            if (string.IsNullOrEmpty(path))
            {
                path = Directory.GetCurrentDirectory();
            }

            if (!Directory.Exists(path))
            {
                throw new Exception(string.Format("The specified path {0} does not exist.", path));
            }

            excludes = DefaultExcludes.Union(excludes).ToArray(); 
            
            var files = Directory.GetFiles(path, filter, SearchOption.AllDirectories).AsEnumerable();

            var separator = Path.DirectorySeparatorChar;

            foreach (var exclude in excludes)
            {
                files = files.Where(f => f.IndexOf(separator + exclude.Trim(separator) + separator) < 0);
            }

            return files.Select(f => Path.GetDirectoryName(f)).Distinct();
        }

        /// <summary>
        /// Creates the directory (recursively) at the specified <paramref name="path"/>.
        /// </summary>
        /// <param name="path">
        /// The fully-qualified path of the directory to create.
        /// </param>
        public static string MakeDirectory(string path)
        {
            return Directory.CreateDirectory(path).FullName;
        }
        
        public static bool TryGetRepositoryRoot(ref string root)
        {
            try
            {
                if (!Directory.Exists(root))
                {
                    return false;
                }
 
                var current = new DirectoryInfo(root);
 
                string path;

                do
                {
                    path = Path.Combine(current.FullName, ".git");
 
                    if (Directory.Exists(path))
                    {
                        root = current.FullName;
 
                        return true;
                    }
                }   while((current = current.Parent) != null);
            }
            catch (Exception netEx)
            {
                Log.Verbose(netEx.Message);
 
                return false;
            }
            
            return false;
        }

        /// <summary>
        /// Gets or sets the log used to emmit log entries.
        /// </summary>
        public static ILog Log { get; set; }
    }

    public static class AssemblyInfo
    {
        private const string VersionExpression = @"(\[assembly[\s:]+{0}\(\"")(.*)(\""\)\])";
        private const string MetadataExpression = @"(\[assembly[\s:]+AssemblyMetadata\([@\""]+{0}\""[\,\s]+[@\""]+)(.*)(\""\)\])";
        private const string ValueFormat = @"${{1}}{0}${{3}}";
        private const string BuildDateFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffK";

        private static readonly Lazy<DateTime> UtcFactory = new Lazy<DateTime>(() =>
            {
                // define the server and port used to connect to the time server
                var server = "time.nist.gov";
                var port = 123;

                try
                {
                    // get the current address of the time server from DNS
                    var addresses = Dns.GetHostEntry(server).AddressList;

                    // create the endpoint using the first address in the response
                    var endpoint = new IPEndPoint(addresses[0], port);

                    // create a byte array to retain the request/response from the socket
                    var data = new byte[48];
                    data[0] = 0x1B;

                    // create a new socket to connect to the time server
                    using (var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp))
                    {
                        // connect to the endpoint
                        socket.Connect(endpoint);

                        // wait no more than 3 seconds for the time to be received
                        socket.ReceiveTimeout = 3000;

                        // send the request
                        socket.Send(data);

                        // get the response
                        socket.Receive(data);
                    }

                    // create the seconds and second fraction bits from the time server
                    ulong seconds = (ulong)data[40] << 24 | (ulong)data[41] << 16 | (ulong)data[42] << 8 | (ulong)data[43];
                    ulong fraction = (ulong)data[44] << 24 | (ulong)data[45] << 16 | (ulong)data[46] << 8 | (ulong)data[47];

                    // calculate the total millisconds since 1900
                    var ms = (seconds * 1000) + ((fraction * 1000) / 0x100000000L);

                    // generate the utc time stamp from the response received via NTP
                    var time = (new DateTime(1900, 1, 1, 0, 0, 0, DateTimeKind.Utc)).AddMilliseconds(ms);

                    // return the server time
                    return time;
                }
                catch (Exception)
                {
                    // log a warning
                    Build.Log.Warn(string.Format("Unable to retrieve time from the time server ({0}) on port {1}, reverting to local time.", server, port));

                    // use local time
                    return DateTime.UtcNow;
                }
            });

        public static string Version { get; set; }

        public static string FileVersion { get; set; }

        public static string InformationalVersion { get; set; }

        public static string Branch { get; set; }

        public static string BuildId { get; set; }

        public static string CommitId { get; set; }
        
        public static DateTime DateTimeUtc
        {
            get
            {
                return UtcFactory.Value;
            }
        }

        /// <summary>
        /// Gets the current date and time as UTC from a time server.
        /// </summary>
        public static string BuildDateUtc
        {
            get
            {
                return DateTimeUtc.ToString(BuildDateFormat);
            }
        }

        public static string BuiltBy { get; set; }

        public static string BuiltOn { get; set; }

        public static string TeamUri { get; set; }

        public static string RepositoryUri { get; set; }

        public static string BuildUri { get; set; }

        public static void LoadGitMetadata(string path)
        {
            if (!Build.TryGetRepositoryRoot(ref path))
            {
                return;
            }

            var node = Path.Combine(path, @".git", "HEAD");

            if (!File.Exists(node))
            {
                return;
            }

            var head = File.ReadAllText(node);

            var match = Regex.Match(head, "^ref: (?<branch>refs/heads/.*)$");

            if (match.Success)
            {
                if (string.IsNullOrEmpty(AssemblyInfo.Branch))
                {
                    AssemblyInfo.Branch = match.Groups["branch"].Value.Trim();
                }

                if (string.IsNullOrEmpty(AssemblyInfo.CommitId))
                {
                    node = Path.Combine(path, @".git", AssemblyInfo.Branch.Replace("/", Path.DirectorySeparatorChar.ToString()));

                    if (File.Exists(node))
                    {
                        AssemblyInfo.CommitId = File.ReadAllText(node).Trim();
                    }
                }
            }
            else
            {
                Build.Log.Verbose("Match was not successful");
                if (string.IsNullOrEmpty(AssemblyInfo.CommitId))
                {
                    AssemblyInfo.CommitId = head.Trim();
                }

                if (string.IsNullOrEmpty(AssemblyInfo.Branch))
                {
                    node = Path.Combine(path, @".git\refs\remotes\origin");

                    AssemblyInfo.Branch = AssemblyInfo.FindBranch(node) ?? "<unknown>";
                }
            }

            node = Path.Combine(path, @".git\config");

            if (!File.Exists(node) || !string.IsNullOrEmpty(AssemblyInfo.RepositoryUri))
            {
                return;
            }

            using (var stream = new StreamReader(path))
            {
                string line;

                while (((line = stream.ReadLine()) != null) && !string.Equals(line.Trim(), "[remote \"origin\"]", StringComparison.OrdinalIgnoreCase)) { }

                if (!string.IsNullOrEmpty(line) && string.Equals(line.Trim(), "[remote \"origin\"]", StringComparison.OrdinalIgnoreCase))
                {
                    match = Regex.Match(stream.ReadLine(), @"^\s+url\s*=\s*(?<url>[^\s]*)\s*$");

                    if (match.Success)
                    {
                        AssemblyInfo.RepositoryUri = match.Groups["url"].Value;

                        if (AssemblyInfo.RepositoryUri.EndsWith(".git"))
                        {
                            AssemblyInfo.RepositoryUri.Substring(0, AssemblyInfo.RepositoryUri.Length - 4);
                        }
                    }
                }
            }
        }

        public static void SaveInfo(string path)
        {
            // determine if the path exists
            if (string.IsNullOrEmpty(path))
            {
                // throw an exception, since we need a path to be able to save the info
                throw new ArgumentNullException("A path must be specified in order to save version info..", path);
            }

            // parse the version
            var version = System.Version.Parse(AssemblyInfo.FileVersion);

            // determine if the informational version is not specified
            if (string.IsNullOrEmpty(AssemblyInfo.InformationalVersion))
            {
                // create an informational version which includes the revision number as a tag
                AssemblyInfo.InformationalVersion = string.Format
                    (@"{0}.{1}.{2}-{3}", version.Major, version.Minor, version.Build, version.Revision);
            }

            if (!File.Exists(path))
            {
                Build.MakeDirectory(Path.GetDirectoryName(path));

                // create a string builder used to create the content
                var builder = new StringBuilder();

                // append the auto generated documentation header
                builder.AppendLine("//------------------------------------------------------------------------------");
                builder.AppendLine("// <auto-generated>");
                builder.AppendLine("// This code was generated by a tool.");
                builder.AppendLine("// </auto-generated>");
                builder.AppendLine("//------------------------------------------------------------------------------");
                builder.AppendLine();

                // add the reflection namespace
                builder.AppendLine("using System.Reflection;");
                builder.AppendLine();

                // determine if the version is specified
                if (!string.IsNullOrEmpty(AssemblyInfo.Version))
                {
                    // append the assembly version
                    builder.AppendFormat(@"[assembly: AssemblyVersion(""{0}.0"")]", AssemblyInfo.Version);
                    builder.AppendLine();

                    // append the assembly file version
                    builder.AppendFormat(@"[assembly: AssemblyFileVersion(""{0}"")]", AssemblyInfo.FileVersion);
                    builder.AppendLine();
                }

                // append the informational version
                builder.AppendFormat(@"[assembly: AssemblyInformationalVersion(""{0}"")]", AssemblyInfo.InformationalVersion);
                builder.AppendLine();

                // add the portable pre-processor directive
                builder.AppendLine("#if !PORTABLE");

                // determine if the branch is specified
                if (!string.IsNullOrEmpty(AssemblyInfo.Branch))
                {
                    // append the branch metadata
                    builder.AppendFormat(@"[assembly: AssemblyMetadata(""{0}"", @""{1}"")]", "Branch", AssemblyInfo.Branch);
                    builder.AppendLine();
                }

                // determine if the build id is specified
                if (!string.IsNullOrEmpty(AssemblyInfo.BuildId))
                {
                    // append the build id metadata
                    builder.AppendFormat(@"[assembly: AssemblyMetadata(""{0}"", @""{1}"")]", "BuildId", AssemblyInfo.BuildId);
                    builder.AppendLine();
                }

                // determine if the commit id is specified
                if (!string.IsNullOrEmpty(AssemblyInfo.CommitId))
                {
                    // append the commit id metadata
                    builder.AppendFormat(@"[assembly: AssemblyMetadata(""{0}"", @""{1}"")]", "CommitId", AssemblyInfo.CommitId);
                    builder.AppendLine();
                }

                // append the build date metadata
                builder.AppendFormat(
                    @"[assembly: AssemblyMetadata(""{0}"", @""{1}"")]",
                    "BuildDateUtc",
                    AssemblyInfo.BuildDateUtc);
                builder.AppendLine();

                // determine if the built by is specified
                if (!string.IsNullOrEmpty(AssemblyInfo.BuiltBy))
                {
                    // append the built by metadata
                    builder.AppendFormat(@"[assembly: AssemblyMetadata(""{0}"", @""{1}"")]", "BuiltBy", AssemblyInfo.BuiltBy);
                    builder.AppendLine();
                }

                // determine if the built on is specified
                if (!string.IsNullOrEmpty(AssemblyInfo.BuiltOn))
                {
                    // append the built on metadata
                    builder.AppendFormat(@"[assembly: AssemblyMetadata(""{0}"", @""{1}"")]", "BuiltOn", AssemblyInfo.BuiltOn);
                    builder.AppendLine();
                }

                // determine if the repository URI is specified
                if (!string.IsNullOrEmpty(AssemblyInfo.RepositoryUri))
                {
                    // append the repository URI metadata
                    builder.AppendFormat(
                        @"[assembly: AssemblyMetadata(""{0}"", @""{1}"")]",
                        "RepositoryUri",
                        AssemblyInfo.RepositoryUri);
                    builder.AppendLine();
                }

                // determine if the team URI is specified
                if (!string.IsNullOrEmpty(AssemblyInfo.TeamUri))
                {
                    // append the repository URI metadata
                    builder.AppendFormat(
                        @"[assembly: AssemblyMetadata(""{0}"", @""{1}"")]",
                        "TeamUri",
                        AssemblyInfo.TeamUri);
                    builder.AppendLine();
                }

                // determine if the build URI is specified
                if (!string.IsNullOrEmpty(AssemblyInfo.BuildUri))
                {
                    // append the repository URI metadata
                    builder.AppendFormat(
                        @"[assembly: AssemblyMetadata(""{0}"", @""{1}"")]",
                        "BuildUri",
                        AssemblyInfo.BuildUri);
                    builder.AppendLine();
                }

                // end the portable pre-processor directive
                builder.AppendLine("#endif");

                File.WriteAllText(path, builder.ToString());

                return;
            }

            // read the contents of the file
            var contents = File.ReadAllText(path);

            contents = AssemblyInfo.VersionReplace(contents, "AssemblyVersion", AssemblyInfo.Version + ".0");
            contents = AssemblyInfo.VersionReplace(contents, "AssemblyFileVersion", AssemblyInfo.FileVersion);
            contents = AssemblyInfo.VersionReplace(contents, "AssemblyInformationalVersion", AssemblyInfo.InformationalVersion);

            contents = AssemblyInfo.MetadataReplace(contents, "BuildDateUtc", AssemblyInfo.BuildDateUtc);

            if (!string.IsNullOrEmpty(Branch))
            {
                contents = AssemblyInfo.MetadataReplace(contents, "Branch", AssemblyInfo.Branch);
            }

            if (!string.IsNullOrEmpty(BuildId))
            {
                contents = AssemblyInfo.MetadataReplace(contents, "BuildId", AssemblyInfo.BuildId);
            }

            if (!string.IsNullOrEmpty(CommitId))
            {
                contents = AssemblyInfo.MetadataReplace(contents, "CommitId", AssemblyInfo.CommitId);
            }

            if (!string.IsNullOrEmpty(BuiltBy))
            {
                contents = AssemblyInfo.MetadataReplace(contents, "BuiltBy", AssemblyInfo.BuiltBy);
            }

            if (!string.IsNullOrEmpty(BuiltOn))
            {
                contents = AssemblyInfo.MetadataReplace(contents, "BuiltOn", AssemblyInfo.BuiltOn);
            }

            if (!string.IsNullOrEmpty(TeamUri))
            {
                contents = AssemblyInfo.MetadataReplace(contents, "TeamUri", AssemblyInfo.TeamUri);
            }

            if (!string.IsNullOrEmpty(RepositoryUri))
            {
                contents = AssemblyInfo.MetadataReplace(contents, "RepositoryUri", AssemblyInfo.RepositoryUri);
            }

            if (!string.IsNullOrEmpty(BuildUri))
            {
                contents = AssemblyInfo.MetadataReplace(contents, "BuildUri", AssemblyInfo.BuildUri);
            }

            File.WriteAllText(path, contents);
        }

        private static string VersionReplace(string contents, string name, string version)
        {
            var expression = string.Format(VersionExpression, name);

            var format = string.Format(ValueFormat, version);

            var regex = new Regex(expression);

            if (!regex.IsMatch(contents))
            {
                contents = string.Concat(contents, "{0}[assembly: ", name, "(\"", version, "\")]");
                return contents;
            }

            return regex.Replace(contents, format, 1);
        }

        private static string MetadataReplace(string contents, string name, string value)
        {
            var expression = string.Format(MetadataExpression, name);
            var format = string.Format(ValueFormat, value);
            
            var regex = new Regex(expression);

            if (!regex.IsMatch(contents))
            {
                contents = string.Concat(contents, Environment.NewLine, "[assembly: AssemblyMetadata(\"", name, "\", @\"", value, "\")]");
                return contents;
            }

            return regex.Replace(contents, format, 1);
        }
        
        private static string FindBranch(string path)
        {
            if (!Directory.Exists(path))
            {
                return null;
            }
            
            foreach (var branch in Directory.GetFiles(path))
            {
                var head = File.ReadAllText(branch).Trim();

                if (string.Equals(AssemblyInfo.CommitId, head))
                {
                    return Path.GetFileName(branch).Trim();
                }

                foreach(var part in Directory.GetDirectories(path))
                {
                    var current = AssemblyInfo.FindBranch(part);
                    
                    if (current != null)
                    {
                        return Path.GetFileName(part) + '/' + current;
                    }
                }
            }

            return null;
        }
    }
}