use namespace = "System"
use namespace = "System.Collections.Generic"
use namespace = "System.IO"
use namespace = "System.Linq"
use namespace = "System.Net"
use namespace = "System.Net.Sockets"

use namespace = "Sake.Engine.Logging"

@{
    // set the log instance on the helper class
    Build.Log = this.Log;
}

functions @{    
    /// <summary>
    /// Represents a helper class used to store and retrieve build environment configuration.
    /// </summary>
    public static class Build
    {
        private static readonly string[] DefaultExcludes = new[] { "node_modules", "bower_components" };

        private static readonly Lazy<DateTime> UtcFactory = new Lazy<DateTime>(() =>
            {
                // define the server and port used to connect to the time server
                var server = "time.nist.gov";
                var port = 123;

                try
                {
                    // get the current address of the time server from DNS
                    var addresses = Dns.GetHostEntry(server).AddressList;

                    // create the endpoint using the first address in the response
                    var endpoint = new IPEndPoint(addresses[0], port);

                    // create a byte array to retain the request/response from the socket
                    var data = new byte[48];
                    data[0] = 0x1B;

                    // create a new socket to connect to the time server
                    using (var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp))
                    {
                        // connect to the endpoint
                        socket.Connect(endpoint);

                        // wait no more than 3 seconds for the time to be received
                        socket.ReceiveTimeout = 3000;

                        // send the request
                        socket.Send(data);

                        // get the response
                        socket.Receive(data);
                    }

                    // create the seconds and second fraction bits from the time server
                    ulong seconds = (ulong)data[40] << 24 | (ulong)data[41] << 16 | (ulong)data[42] << 8 | (ulong)data[43];
                    ulong fraction = (ulong)data[44] << 24 | (ulong)data[45] << 16 | (ulong)data[46] << 8 | (ulong)data[47];

                    // calculate the total millisconds since 1900
                    var ms = (seconds * 1000) + ((fraction * 1000) / 0x100000000L);

                    // generate the utc time stamp from the response received via NTP
                    var time = (new DateTime(1900, 1, 1, 0, 0, 0, DateTimeKind.Utc)).AddMilliseconds(ms);

                    // return the server time
                    return time;
                }
                catch (Exception)
                {
                    // log a warning
                    Log.Warn(string.Format("Unable to retrieve time from the time server ({0}) on port {1}, reverting to local time.", server, port));

                    // use local time
                    return DateTime.UtcNow;
                }
            });

        /// <summary>
        /// Gets a value indicating whether or not the build environment is running on a Unix-based 
        /// host.
        /// </summary>
        public static bool Unix
        {
            get
            {
                // get the platform identifier as an integer
                // tricky: this is necessary as the 1.x mono runtime used a value of 128 for 
                // unix environments, which doesn't exist on the PlatformID enumeration in 
                // .NET or in 2.x mono runtime
                var id = (int)Environment.OSVersion.Platform;

                // tricky:
                //  - 4 = Mac OS X (DNX / Mono 2.x)
                //  - 6 = Unix (DNX / Mono 2.x)
                //  - 128 = Unix (Mono 1.x)
                return id == 4 || id == 6 || id == 128;
            }
        }

        /// <summary>
        /// Gets a value indicating whether or not the build environment is executing within the 
        /// mono runtime.
        /// </summary>
        public static bool Mono
        {
            get
            {
                return Type.GetType("Mono.Runtime") != null;
            }
        }

        /// <summary>
        /// Gets the value of the environment variable with the specified <paramref name="key"/>.
        /// </summary>
        /// <param name="key">
        /// The name of the environment variable for which to retrieve a value.
        /// </param>
        /// <returns>
        /// The value of the environment variable with the specified <paramref name="key"/>; otherwise 
        /// <see langword="null"/>.
        /// </returns>
        public static string Variable(string key)
        {
            // get the environment variable
            return Environment.GetEnvironmentVariable(key) ?? string.Empty;
        }

        /// <summary>
        /// Sets the environment variable with the specified <paramref name="key"/> to the specified 
        /// <paramref name="value"/>.
        /// </summary>
        /// <param name="key">
        /// The name of the environment variable to set to the specified <paramref name="value"/>.
        /// </param>
        /// <param name="value">
        /// The value to which to set the environment variable with the specified <paramref name="key"/>.
        /// </param>
        /// <param name="replace">
        /// A value indicating whether or not to append the value to any existing value.
        /// </param>
        public static void Variable(string key, string value, bool append = false)
        {
            // determine if the value is being appended
            if (append)
            {
                // get the current value and append the new value; finally trim any whitespace
                value = string.Concat(Build.Variable(key), " ", value).Trim();
            }

            // set the environment variable
            Environment.SetEnvironmentVariable(key, value);
        }

        public static bool TryExecute(string command, out int exitCode, string args = "", string workingPath = "")
        {
            try
            {
                // attempt to execute the command
                exitCode = Build.Execute(command, args, workingPath);
            }
            catch
            {
                // set the exit code to -1 as a default error
                exitCode = -1;
            }

            // return true if the exit code is 0
            return exitCode == 0;
        }

        public static bool TryExecute(string command, string args = "", string workingPath = "")
        {
            int exitCode;

            return Build.TryExecute(command, out exitCode, args, workingPath);
        }

        /// <summary>
        /// Executes the specified <paramref name="command"/> with the specified <paramref name="arguments"/> and determines
        /// whether or not it succeeds at the command line.
        /// </summary>
        /// <param name="command">
        /// The command to execute at the command line.
        /// </param>
        /// <param name="arguments">
        /// The arguments to execute at the command line.
        /// </param>
        /// <param name="workingPath">
        /// The path in which to execute the specified <paramref name="command"/>.
        /// </param>
        public static int Execute(string command, string args = "", string workingPath = "")
        {
            // determine if the working path is specified
            if (string.IsNullOrEmpty(workingPath))
            {
                // set the working path to the current directory
                workingPath = Directory.GetCurrentDirectory();
            }

            // determine process start information based on whether or not the CLI is executing on unix/linux or windows
            var info = Build.Unix
                ? new ProcessStartInfo { FileName = command, Arguments = args }
                : new ProcessStartInfo { FileName = "cmd", Arguments = "/C " + command + " " + args };

            info.WorkingDirectory = workingPath;
            info.UseShellExecute = false;

            // start the process
            var process = Process.Start(info);

            // wait for the process to exit
            process.WaitForExit();

            // get the exit code
            return process.ExitCode;
        }

        public static IEnumerable<string> GetPathsContaining(string path, string filter, params string[] excludes)
        {
            if (string.IsNullOrEmpty(path))
            {
                path = Directory.GetCurrentDirectory();
            }

            if (!Directory.Exists(path))
            {
                throw new Exception(string.Format("The specified path {0} does not exist.", path));
            }

            excludes = DefaultExcludes.Union(excludes).ToArray(); 
            
            var files = Directory.GetFiles(path, filter, SearchOption.AllDirectories).AsEnumerable();

            var separator = Path.DirectorySeparatorChar;

            foreach (var exclude in excludes)
            {
                files = files.Where(f => f.IndexOf(separator + exclude.Trim(separator) + separator) < 0);
            }

            return files.Select(f => Path.GetDirectoryName(f)).Distinct();
        }
        
        /// <summary>
        /// Gets the current date and time as UTC from a time server.
        /// </summary>
        public static DateTime Utc
        {
            get
            {
                return UtcFactory.Value;
            }
        }

        /// <summary>
        /// Creates the directory (recursively) at the specified <paramref name="path"/>.
        /// </summary>
        /// <param name="path">
        /// The fully-qualified path of the directory to create.
        /// </param>
        public static string MakeDirectory(string path)
        {
            return Directory.CreateDirectory(path).FullName;
        }

        /// <summary>
        /// Gets or sets the log used to emmit log entries.
        /// </summary>
        public static ILog Log { get; set; }
    }
}